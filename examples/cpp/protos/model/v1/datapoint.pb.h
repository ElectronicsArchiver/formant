// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/model/v1/datapoint.proto

#ifndef PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto
#define PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "protos/model/v1/file.pb.h"
#include "protos/model/v1/health.pb.h"
#include "protos/model/v1/math.pb.h"
#include "protos/model/v1/navigation.pb.h"
#include "protos/model/v1/text.pb.h"
#include "protos/model/v1/media.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fmodel_2fv1_2fdatapoint_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmodel_2fv1_2fdatapoint_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_protos_2fmodel_2fv1_2fdatapoint_2eproto();
namespace v1 {
namespace model {
class Datapoint;
class DatapointDefaultTypeInternal;
extern DatapointDefaultTypeInternal _Datapoint_default_instance_;
class Datapoint_TagsEntry_DoNotUse;
class Datapoint_TagsEntry_DoNotUseDefaultTypeInternal;
extern Datapoint_TagsEntry_DoNotUseDefaultTypeInternal _Datapoint_TagsEntry_DoNotUse_default_instance_;
}  // namespace model
}  // namespace v1
namespace google {
namespace protobuf {
template<> ::v1::model::Datapoint* Arena::CreateMaybeMessage<::v1::model::Datapoint>(Arena*);
template<> ::v1::model::Datapoint_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::Datapoint_TagsEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace v1 {
namespace model {

// ===================================================================

class Datapoint_TagsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Datapoint_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<Datapoint_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Datapoint_TagsEntry_DoNotUse();
  Datapoint_TagsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Datapoint_TagsEntry_DoNotUse& other);
  static const Datapoint_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Datapoint_TagsEntry_DoNotUse*>(&_Datapoint_TagsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Datapoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:v1.model.Datapoint) */ {
 public:
  Datapoint();
  virtual ~Datapoint();

  Datapoint(const Datapoint& from);

  inline Datapoint& operator=(const Datapoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Datapoint(Datapoint&& from) noexcept
    : Datapoint() {
    *this = ::std::move(from);
  }

  inline Datapoint& operator=(Datapoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Datapoint& default_instance();

  enum DataCase {
    kText = 4,
    kNumeric = 5,
    kMetricSet = 6,
    kBitset = 7,
    kFile = 8,
    kImage = 9,
    kPointCloud = 10,
    kLocation = 11,
    kLocalization = 12,
    kHealth = 13,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Datapoint* internal_default_instance() {
    return reinterpret_cast<const Datapoint*>(
               &_Datapoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Datapoint* other);
  friend void swap(Datapoint& a, Datapoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Datapoint* New() const final {
    return CreateMaybeMessage<Datapoint>(nullptr);
  }

  Datapoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Datapoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Datapoint& from);
  void MergeFrom(const Datapoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datapoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      tags() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_tags();

  // string stream = 1;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  const ::std::string& stream() const;
  void set_stream(const ::std::string& value);
  #if LANG_CXX11
  void set_stream(::std::string&& value);
  #endif
  void set_stream(const char* value);
  void set_stream(const char* value, size_t size);
  ::std::string* mutable_stream();
  ::std::string* release_stream();
  void set_allocated_stream(::std::string* stream);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .v1.model.Text text = 4;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::v1::model::Text& text() const;
  ::v1::model::Text* release_text();
  ::v1::model::Text* mutable_text();
  void set_allocated_text(::v1::model::Text* text);

  // .v1.model.Numeric numeric = 5;
  bool has_numeric() const;
  void clear_numeric();
  static const int kNumericFieldNumber = 5;
  const ::v1::model::Numeric& numeric() const;
  ::v1::model::Numeric* release_numeric();
  ::v1::model::Numeric* mutable_numeric();
  void set_allocated_numeric(::v1::model::Numeric* numeric);

  // .v1.model.MetricSet metric_set = 6;
  bool has_metric_set() const;
  void clear_metric_set();
  static const int kMetricSetFieldNumber = 6;
  const ::v1::model::MetricSet& metric_set() const;
  ::v1::model::MetricSet* release_metric_set();
  ::v1::model::MetricSet* mutable_metric_set();
  void set_allocated_metric_set(::v1::model::MetricSet* metric_set);

  // .v1.model.Bitset bitset = 7;
  bool has_bitset() const;
  void clear_bitset();
  static const int kBitsetFieldNumber = 7;
  const ::v1::model::Bitset& bitset() const;
  ::v1::model::Bitset* release_bitset();
  ::v1::model::Bitset* mutable_bitset();
  void set_allocated_bitset(::v1::model::Bitset* bitset);

  // .v1.model.File file = 8;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 8;
  const ::v1::model::File& file() const;
  ::v1::model::File* release_file();
  ::v1::model::File* mutable_file();
  void set_allocated_file(::v1::model::File* file);

  // .v1.model.Image image = 9;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 9;
  const ::v1::model::Image& image() const;
  ::v1::model::Image* release_image();
  ::v1::model::Image* mutable_image();
  void set_allocated_image(::v1::model::Image* image);

  // .v1.model.PointCloud point_cloud = 10;
  bool has_point_cloud() const;
  void clear_point_cloud();
  static const int kPointCloudFieldNumber = 10;
  const ::v1::model::PointCloud& point_cloud() const;
  ::v1::model::PointCloud* release_point_cloud();
  ::v1::model::PointCloud* mutable_point_cloud();
  void set_allocated_point_cloud(::v1::model::PointCloud* point_cloud);

  // .v1.model.Location location = 11;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 11;
  const ::v1::model::Location& location() const;
  ::v1::model::Location* release_location();
  ::v1::model::Location* mutable_location();
  void set_allocated_location(::v1::model::Location* location);

  // .v1.model.Localization localization = 12;
  bool has_localization() const;
  void clear_localization();
  static const int kLocalizationFieldNumber = 12;
  const ::v1::model::Localization& localization() const;
  ::v1::model::Localization* release_localization();
  ::v1::model::Localization* mutable_localization();
  void set_allocated_localization(::v1::model::Localization* localization);

  // .v1.model.Health health = 13;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 13;
  const ::v1::model::Health& health() const;
  ::v1::model::Health* release_health();
  ::v1::model::Health* mutable_health();
  void set_allocated_health(::v1::model::Health* health);

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.Datapoint)
 private:
  class HasBitSetters;
  void set_has_text();
  void set_has_numeric();
  void set_has_metric_set();
  void set_has_bitset();
  void set_has_file();
  void set_has_image();
  void set_has_point_cloud();
  void set_has_location();
  void set_has_localization();
  void set_has_health();

  inline bool has_data() const;
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Datapoint_TagsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > tags_;
  ::google::protobuf::internal::ArenaStringPtr stream_;
  ::google::protobuf::int64 timestamp_;
  union DataUnion {
    DataUnion() {}
    ::v1::model::Text* text_;
    ::v1::model::Numeric* numeric_;
    ::v1::model::MetricSet* metric_set_;
    ::v1::model::Bitset* bitset_;
    ::v1::model::File* file_;
    ::v1::model::Image* image_;
    ::v1::model::PointCloud* point_cloud_;
    ::v1::model::Location* location_;
    ::v1::model::Localization* localization_;
    ::v1::model::Health* health_;
  } data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fdatapoint_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Datapoint

// string stream = 1;
inline void Datapoint::clear_stream() {
  stream_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Datapoint::stream() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.stream)
  return stream_.GetNoArena();
}
inline void Datapoint::set_stream(const ::std::string& value) {
  
  stream_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.model.Datapoint.stream)
}
#if LANG_CXX11
inline void Datapoint::set_stream(::std::string&& value) {
  
  stream_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.model.Datapoint.stream)
}
#endif
inline void Datapoint::set_stream(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stream_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.model.Datapoint.stream)
}
inline void Datapoint::set_stream(const char* value, size_t size) {
  
  stream_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.model.Datapoint.stream)
}
inline ::std::string* Datapoint::mutable_stream() {
  
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.stream)
  return stream_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Datapoint::release_stream() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.stream)
  
  return stream_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Datapoint::set_allocated_stream(::std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  stream_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stream);
  // @@protoc_insertion_point(field_set_allocated:v1.model.Datapoint.stream)
}

// int64 timestamp = 2;
inline void Datapoint::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Datapoint::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.timestamp)
  return timestamp_;
}
inline void Datapoint::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:v1.model.Datapoint.timestamp)
}

// map<string, string> tags = 3;
inline int Datapoint::tags_size() const {
  return tags_.size();
}
inline void Datapoint::clear_tags() {
  tags_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Datapoint::tags() const {
  // @@protoc_insertion_point(field_map:v1.model.Datapoint.tags)
  return tags_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Datapoint::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.Datapoint.tags)
  return tags_.MutableMap();
}

// .v1.model.Text text = 4;
inline bool Datapoint::has_text() const {
  return data_case() == kText;
}
inline void Datapoint::set_has_text() {
  _oneof_case_[0] = kText;
}
inline ::v1::model::Text* Datapoint::release_text() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.text)
  if (has_text()) {
    clear_has_data();
      ::v1::model::Text* temp = data_.text_;
    data_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Text& Datapoint::text() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.text)
  return has_text()
      ? *data_.text_
      : *reinterpret_cast< ::v1::model::Text*>(&::v1::model::_Text_default_instance_);
}
inline ::v1::model::Text* Datapoint::mutable_text() {
  if (!has_text()) {
    clear_data();
    set_has_text();
    data_.text_ = CreateMaybeMessage< ::v1::model::Text >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.text)
  return data_.text_;
}

// .v1.model.Numeric numeric = 5;
inline bool Datapoint::has_numeric() const {
  return data_case() == kNumeric;
}
inline void Datapoint::set_has_numeric() {
  _oneof_case_[0] = kNumeric;
}
inline ::v1::model::Numeric* Datapoint::release_numeric() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.numeric)
  if (has_numeric()) {
    clear_has_data();
      ::v1::model::Numeric* temp = data_.numeric_;
    data_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Numeric& Datapoint::numeric() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.numeric)
  return has_numeric()
      ? *data_.numeric_
      : *reinterpret_cast< ::v1::model::Numeric*>(&::v1::model::_Numeric_default_instance_);
}
inline ::v1::model::Numeric* Datapoint::mutable_numeric() {
  if (!has_numeric()) {
    clear_data();
    set_has_numeric();
    data_.numeric_ = CreateMaybeMessage< ::v1::model::Numeric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.numeric)
  return data_.numeric_;
}

// .v1.model.MetricSet metric_set = 6;
inline bool Datapoint::has_metric_set() const {
  return data_case() == kMetricSet;
}
inline void Datapoint::set_has_metric_set() {
  _oneof_case_[0] = kMetricSet;
}
inline ::v1::model::MetricSet* Datapoint::release_metric_set() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.metric_set)
  if (has_metric_set()) {
    clear_has_data();
      ::v1::model::MetricSet* temp = data_.metric_set_;
    data_.metric_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::MetricSet& Datapoint::metric_set() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.metric_set)
  return has_metric_set()
      ? *data_.metric_set_
      : *reinterpret_cast< ::v1::model::MetricSet*>(&::v1::model::_MetricSet_default_instance_);
}
inline ::v1::model::MetricSet* Datapoint::mutable_metric_set() {
  if (!has_metric_set()) {
    clear_data();
    set_has_metric_set();
    data_.metric_set_ = CreateMaybeMessage< ::v1::model::MetricSet >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.metric_set)
  return data_.metric_set_;
}

// .v1.model.Bitset bitset = 7;
inline bool Datapoint::has_bitset() const {
  return data_case() == kBitset;
}
inline void Datapoint::set_has_bitset() {
  _oneof_case_[0] = kBitset;
}
inline ::v1::model::Bitset* Datapoint::release_bitset() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.bitset)
  if (has_bitset()) {
    clear_has_data();
      ::v1::model::Bitset* temp = data_.bitset_;
    data_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Bitset& Datapoint::bitset() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.bitset)
  return has_bitset()
      ? *data_.bitset_
      : *reinterpret_cast< ::v1::model::Bitset*>(&::v1::model::_Bitset_default_instance_);
}
inline ::v1::model::Bitset* Datapoint::mutable_bitset() {
  if (!has_bitset()) {
    clear_data();
    set_has_bitset();
    data_.bitset_ = CreateMaybeMessage< ::v1::model::Bitset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.bitset)
  return data_.bitset_;
}

// .v1.model.File file = 8;
inline bool Datapoint::has_file() const {
  return data_case() == kFile;
}
inline void Datapoint::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline ::v1::model::File* Datapoint::release_file() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.file)
  if (has_file()) {
    clear_has_data();
      ::v1::model::File* temp = data_.file_;
    data_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::File& Datapoint::file() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.file)
  return has_file()
      ? *data_.file_
      : *reinterpret_cast< ::v1::model::File*>(&::v1::model::_File_default_instance_);
}
inline ::v1::model::File* Datapoint::mutable_file() {
  if (!has_file()) {
    clear_data();
    set_has_file();
    data_.file_ = CreateMaybeMessage< ::v1::model::File >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.file)
  return data_.file_;
}

// .v1.model.Image image = 9;
inline bool Datapoint::has_image() const {
  return data_case() == kImage;
}
inline void Datapoint::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline ::v1::model::Image* Datapoint::release_image() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.image)
  if (has_image()) {
    clear_has_data();
      ::v1::model::Image* temp = data_.image_;
    data_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Image& Datapoint::image() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.image)
  return has_image()
      ? *data_.image_
      : *reinterpret_cast< ::v1::model::Image*>(&::v1::model::_Image_default_instance_);
}
inline ::v1::model::Image* Datapoint::mutable_image() {
  if (!has_image()) {
    clear_data();
    set_has_image();
    data_.image_ = CreateMaybeMessage< ::v1::model::Image >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.image)
  return data_.image_;
}

// .v1.model.PointCloud point_cloud = 10;
inline bool Datapoint::has_point_cloud() const {
  return data_case() == kPointCloud;
}
inline void Datapoint::set_has_point_cloud() {
  _oneof_case_[0] = kPointCloud;
}
inline ::v1::model::PointCloud* Datapoint::release_point_cloud() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.point_cloud)
  if (has_point_cloud()) {
    clear_has_data();
      ::v1::model::PointCloud* temp = data_.point_cloud_;
    data_.point_cloud_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::PointCloud& Datapoint::point_cloud() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.point_cloud)
  return has_point_cloud()
      ? *data_.point_cloud_
      : *reinterpret_cast< ::v1::model::PointCloud*>(&::v1::model::_PointCloud_default_instance_);
}
inline ::v1::model::PointCloud* Datapoint::mutable_point_cloud() {
  if (!has_point_cloud()) {
    clear_data();
    set_has_point_cloud();
    data_.point_cloud_ = CreateMaybeMessage< ::v1::model::PointCloud >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.point_cloud)
  return data_.point_cloud_;
}

// .v1.model.Location location = 11;
inline bool Datapoint::has_location() const {
  return data_case() == kLocation;
}
inline void Datapoint::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline ::v1::model::Location* Datapoint::release_location() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.location)
  if (has_location()) {
    clear_has_data();
      ::v1::model::Location* temp = data_.location_;
    data_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Location& Datapoint::location() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.location)
  return has_location()
      ? *data_.location_
      : *reinterpret_cast< ::v1::model::Location*>(&::v1::model::_Location_default_instance_);
}
inline ::v1::model::Location* Datapoint::mutable_location() {
  if (!has_location()) {
    clear_data();
    set_has_location();
    data_.location_ = CreateMaybeMessage< ::v1::model::Location >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.location)
  return data_.location_;
}

// .v1.model.Localization localization = 12;
inline bool Datapoint::has_localization() const {
  return data_case() == kLocalization;
}
inline void Datapoint::set_has_localization() {
  _oneof_case_[0] = kLocalization;
}
inline ::v1::model::Localization* Datapoint::release_localization() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.localization)
  if (has_localization()) {
    clear_has_data();
      ::v1::model::Localization* temp = data_.localization_;
    data_.localization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Localization& Datapoint::localization() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.localization)
  return has_localization()
      ? *data_.localization_
      : *reinterpret_cast< ::v1::model::Localization*>(&::v1::model::_Localization_default_instance_);
}
inline ::v1::model::Localization* Datapoint::mutable_localization() {
  if (!has_localization()) {
    clear_data();
    set_has_localization();
    data_.localization_ = CreateMaybeMessage< ::v1::model::Localization >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.localization)
  return data_.localization_;
}

// .v1.model.Health health = 13;
inline bool Datapoint::has_health() const {
  return data_case() == kHealth;
}
inline void Datapoint::set_has_health() {
  _oneof_case_[0] = kHealth;
}
inline ::v1::model::Health* Datapoint::release_health() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.health)
  if (has_health()) {
    clear_has_data();
      ::v1::model::Health* temp = data_.health_;
    data_.health_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Health& Datapoint::health() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.health)
  return has_health()
      ? *data_.health_
      : *reinterpret_cast< ::v1::model::Health*>(&::v1::model::_Health_default_instance_);
}
inline ::v1::model::Health* Datapoint::mutable_health() {
  if (!has_health()) {
    clear_data();
    set_has_health();
    data_.health_ = CreateMaybeMessage< ::v1::model::Health >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.health)
  return data_.health_;
}

inline bool Datapoint::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Datapoint::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Datapoint::DataCase Datapoint::data_case() const {
  return Datapoint::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace v1

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto
